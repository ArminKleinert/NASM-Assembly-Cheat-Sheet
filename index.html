<html><head><link rel="stylesheet" href="markdown.css"><title></title></head><body><h1>Assembly-Cheat-Sheet:</h1>

<h2>Register:</h2>

<table style="background-color: #f8f9fa;color: #202122;margin: 1em 0;border: 1px solid #a2a9b1;border-collapse: collapse;"><tbody><tr><th>Register</th><th style="width: 12%;" colspan="8">Accumulator</th><th style="width: 12%;" colspan="8">Counter</th><th style="width: 12%;" colspan="8">Data</th><th style="width: 12%;" colspan="8">Base</th><th style="width: 12%;" colspan="8">Stack Pointer</th><th style="width: 12%;" colspan="8">Stack Base Pointer</th><th style="width: 12%;" colspan="8">Source</th><th style="width: 12%;" colspan="8">Destination</th></tr><tr style="text-align: center;"><th scope="row">64-bit</th><td colspan="8">RAX</td><td colspan="8">RCX</td><td colspan="8">RDX</td><td colspan="8">RBX</td><td colspan="8">RSP</td><td colspan="8">RBP</td><td colspan="8">RSI</td><td colspan="8">RDI</td></tr><tr style="text-align: center;"><th scope="row">32-bit</th><td style="width: 6%;" colspan="4"></td><td style="width: 6%;" colspan="4">EAX</td><td style="width: 6%;" colspan="4"></td><td style="width: 6%;" colspan="4">ECX</td><td style="width: 6%;" colspan="4"></td><td style="width: 6%;" colspan="4">EDX</td><td style="width: 6%;" colspan="4"></td><td style="width: 6%;" colspan="4">EBX</td><td style="width: 6%;" colspan="4"></td><td style="width: 6%;" colspan="4">ESP</td><td style="width: 6%;" colspan="4"></td><td style="width: 6%;" colspan="4">EBP</td><td style="width: 6%;" colspan="4"></td><td style="width: 6%;" colspan="4">ESI</td><td style="width: 6%;" colspan="4"></td><td style="width: 6%;" colspan="4">EDI</td></tr><tr style="text-align: center;"><th scope="row">16-bit</th><td style="width: 9%;" colspan="6"></td><td style="width: 3%;" colspan="2">AX</td><td style="width: 9%;" colspan="6"></td><td style="width: 3%;" colspan="2">CX</td><td style="width: 9%;" colspan="6"></td><td style="width: 3%;" colspan="2">DX</td><td style="width: 9%;" colspan="6"></td><td style="width: 3%;" colspan="2">BX</td><td style="width: 9%;" colspan="6"></td><td style="width: 3%;" colspan="2">SP</td><td style="width: 9%;" colspan="6"></td><td style="width: 3%;" colspan="2">BP</td><td style="width: 9%;" colspan="6"></td><td style="width: 3%;" colspan="2">SI</td><td style="width: 9%;" colspan="6"></td><td style="width: 3%;" colspan="2">DI</td></tr><tr style="text-align: center;"><th scope="row">8-bit</th><td style="width: 9%;" colspan="6"></td><td style="width: 1.5%;" colspan="1">AH</td><td style="width: 1.5%;" colspan="1">AL</td><td style="width: 9%;" colspan="6"></td><td style="width: 1.5%;" colspan="1">CH</td><td style="width: 1.5%;" colspan="1">CL</td><td style="width: 9%;" colspan="6"></td><td style="width: 1.5%;" colspan="1">DH</td><td style="width: 1.5%;" colspan="1">DL</td><td style="width: 9%;" colspan="6"></td><td style="width: 1.5%;" colspan="1">BH</td><td style="width: 1.5%;" colspan="1">BL</td><td style="width: 9%;" colspan="7"></td><td style="width: 1.5%;" colspan="1">SPL</td><td style="width: 9%;" colspan="7"></td><td style="width: 1.5%;" colspan="1">BPL</td><td style="width: 9%;" colspan="7"></td><td style="width: 1.5%;" colspan="1">SIL</td><td style="width: 9%;" colspan="7"></td><td style="width: 1.5%;" colspan="1">DIL</td></tr></tbody><caption></caption></table>

<h3>Eingabe-Register</h3>

<p>Funktionsparameter werden in folgenden Registern übermittelt:</p>

<table><thead>
<tr>
<th><span></th>
<th><span></th>
<th><span></th>
<th><span></th>
<th><span></th>
<th><span></th>
<th><span></th>
<th><span></th>
</tr>
</thead><tbody>
<tr>
<td>Parameter Nummer</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7+</td>
</tr>
<tr>
<td>Register</td>
<td>rdi</td>
<td>rsi</td>
<td>rdx</td>
<td>rcx</td>
<td>r8</td>
<td>r9</td>
<td>Stack</td>
</tr>
</tbody></table>

<h3>Rückgabe-Register</h3>

<p>Der Rückgabewert einer Funktion steht im <strong>rax</strong> Register. Achtet dabei darauf, dass ihr euer Ergebnis immer ins rax Register schreibt.</p>

<h3>Volatile- vs Non-Volatile-Registers:</h3>

<p>Nach Calling-Convention werden die Register in 2 Kategorien eingeteilt: Volatile und Non-Volatile. Non-Volatile-Register behalten, nach Calling-Convention, nach einem Funktionsaufruf ihren Wert. D.h. wir müssen uns nicht um die Sicherung dieser Register kümmern, wenn wir eine weitere Funktion aufrufen. Dies bedeutet aber auch automatisch, dass wir diese Register auf dem Stack sichern müssen (PUSH), wenn wir sie verwenden wollen, und sie wiederherstellen (POP) bevor unsere Funktion beendet.
Volatile-Register auf der anderen Seite verhalten sich genau andersherum: Wir dürfen die Wert die dort gespeichert sind verändern, ohne uns um eine Sicherung Gedanken machen zu müssen. Wollen wir jedoch ihren Wert über einen weiteren Funktionsaufruf behalten, müssen wir sie manuell vor dem Aufruf sichern.</p>

<table><thead>
<tr>
<th>Register</th>
<th>Volatile</th>
<th>Non-Volatile</th>
</tr>
</thead><tbody>
<tr>
<td>rax</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>rbx</td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>rcx</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>rdx</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>rsp</td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>rbp</td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>rsi</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>rdi</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>r8-r11</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>r12-r15</td>
<td></td>
<td>X</td>
</tr>
</tbody></table>

<h2>Befehle</h2>

<h3>Bewegung von Daten:</h3>

<h4>MOV reg (to), value / MOV reg (to), reg (from):</h4>

<p>Definition: Verschiebe ein Wert bzw. den Wert eines Registers in ein weiteres Register.</p>

<p>Beispiel:</p>

<pre><code>MOV rax, rdx ; Verschiebe Wert von rdx in rax (ergo rax = rdx)
MOV rsi, 2   ; Verschiebe die Zahl 2 in das Register rsi (ergo rsi = 2)
</code></pre>

<h4>SHL reg (value 1), value / SHL reg (value 1), reg (value 2)</h4>

<p>Definition: Shifte den Wert des Registers um n Stellen nach Links. Bits die nach Links &ldquo;rausgeschoben&rdquo; werden gehen verloren</p>

<p>Beispiel:</p>

<pre><code>SHL rax, rdx ; Verschiebe alle Bits von rax um n-Stellen (Entsprechend des Wertes aus rdx)
SHL rax, 1   ; Verschiebe alle Bits 
</code></pre>

<p>Beispiel under the hood:</p>

<pre><code>rax = 1100 0011

SHL rax, 1

=&gt; rax = 1000 0110
</code></pre>

<h4>SHR reg (value 1), value / SHR reg (value 1), reg (value 2)</h4>

<p>Definition: Shifte den Wert des Registers um n Stellen nach Rechts. Also analog zu SHL</p>

<p>Beispiel:</p>

<pre><code>SHR rax, rdx
SHR rax, 1
</code></pre>

<h4>ROL reg (value 1), value / ROL reg (value 1), reg (value 2)</h4>

<p>Definition: Rotiere die Werte um n Stelle. Dies ist Analog zu SHL jedoch gehen hier die Bits die nach links raus geschoben werden nicht verloren, sondern werden rechts hinzugefügt.</p>

<p>Beispiel:</p>

<pre><code>ROL rax, rdx
ROL rax, 1
</code></pre>

<p>Beispiel under the hood:</p>

<pre><code>rax = 1100 0100

ROL rax, 1
=&gt; rax = 1000 1001
</code></pre>

<h4>ROR reg (value 1), value / ROR reg (value 1), reg (value 2)</h4>

<p>Definition: Rotiere die Werte um n Stellen nach Rechts. Also analog zu ROL</p>

<p>Beispiel:</p>

<pre><code>ROR rax, rdx
ROR rax, 1
</code></pre>

<h3>Bit-Operationen:</h3>

<h4>AND reg (value 1), value / AND reg (value 1), reg (value 2)</h4>

<p>Definition: Wendet das logische UND mit dem Wert des zweiten Parameters auf den Wert des ersten Registers an und speichert das Ergebnis im ersten Register.</p>

<p>Beispiel:</p>

<pre><code>AND rax, rsi ; Verunde den Wert aus rax mit dem Wert aus rsi
AND rax, 0x1 ; Verunde den Wert aus rax mit dem Wert 0x1 (Hexadezimal-Zahl)
</code></pre>

<p>Beispiel under the hood:</p>

<pre><code>rax = 0101 1101
rsi = 1101 1011

AND rax, rsi = 0101 1101 AND 1101 1011

0101 1101
1001 1011
---------
0001 1001 = rax
</code></pre>

<h4>OR reg (value 1), value / OR reg (value 1), reg (value 2)</h4>

<p>Definition: Wende das logische ODER mit dem Wert des zweiten Parameters auf das erste Register an und speichert das Ergebnis im ersten Register.</p>

<p>Beispiel:</p>

<pre><code>OR rax, rsi ; Veroder den Wert aus rax mit dem Wert aus rsi
OR rdx, 0xF ; Veroder den Wert aus rdx mit dem Wert 0xF (Binär = 1111)
</code></pre>

<p>Beispiel under the hood:</p>

<pre><code>rdx = 0011 1101
0xF = 0000 1101

OR rdx, 0xF = 0011 1101 OR 0000 1101

0011 1101
0000 1101
---------
0011 1101 = rdx
</code></pre>

<h4>XOR reg (value 1), value / XOR reg (value 1), reg (value 2):</h4>

<p>Definition: Wendet das logische XOR mit dem Wert des zweiten Parameters auf den Wert des ersten Registers an.</p>

<p>Beispiel:</p>

<pre><code>XOR rax, rsi  ; Wendet XOR auf den Wert von rax mit dem Wert von rsi an
XOR rdx, 0x8F ; Wendet XOR auf den Wert von rdx mit 0x8F (Binär = 1000 1111) an
</code></pre>

<p>Beispiel under the hood:</p>

<pre><code>rdx  = 0011 1011
0xFF = 1000 1111

XOR rdx, 0x8F

0011 1011
1000 1111
---------
0000 1011 = rdx
</code></pre>

<h3>Arithmetische-Operationen:</h3>

<h4>NEG reg (value 1):</h4>

<p>Definition: Negiere den Wert aus dem gegebenen Register (in 2k)</p>

<p>Beispiel:</p>

<pre><code>NEG rsi ; Negiere den Wert in rsi
</code></pre>

<h4>ADD reg (value 1), value / ADD reg (value 1), reg (value 2):</h4>

<p>Definition: Addiere einen Wert bzw. den Wert eines Registers auf den Wert eines anderen Registers.</p>

<p>Beispiel:</p>

<pre><code>ADD rax, rdx ; Addiere Wert von rdx auf rax und Speicher Ergebnis in rax (rax = rax + rdx)
ADD rsi, 2   ; Addiere die Zahl 2 auf rsi und Speicher Ergebnis in rsi (rsi = rsi + 2)
</code></pre>

<h4>SUB reg (value 1), value / SUB reg (value 1), reg (value 2):</h4>

<p>Definition: Analog zu Add jedoch als Subtraktion</p>

<p>Beispiele:</p>

<pre><code>SUB rax, rdx ; Subtrahiere von rax den Wert von rdx und speichere das Ergebnis in rax (rax = rax - rdx)
SUB rsi, 2   ; Subtrahiere von rsi den Wert 2 (rsi = rsi - 2)
</code></pre>

<h4>MUL reg (value 1):</h4>

<p>Definition: Multipliziere den Wert in Register rax mit dem Wert des angegebenen Registers. Das Ergebnis wird in die <em>beiden (!!!)</em> Register rax und rdx gespeichert (rdx, falls ein Überlauf der Zahl in rax passiert)</p>

<p>Beispiel:</p>

<pre><code>MUL rsi ; Multipliziere den Wert in rax mit dem Wert aus rsi und speichere das Ergebnis in (rdx) rax
</code></pre>

<p>ACHTUNG: Dieser Befehl kann nicht mit einem Wert genutzt werden. Falls man das Register rax mit einem bestimmten Wert multiplizieren möchte muss man diesen vorher in ein Register verschieben:</p>

<pre><code>MOV rsi, 3
MUL rsi    ; Multipliziere rax mit 3
</code></pre>

<h4>DIV reg (value 1):</h4>

<p>Definition: Dividiere den Wert aus rdx:rax (rdx konkateniert mit rax) durch den Wert aus dem angegebenen Register. Ergebnis wird in rax (ganzzahlige Division) und rdx (Rest) gespeichert</p>

<p>Beispiel:</p>

<pre><code>DIV rsi ; Dividiert rdx:rax durch den Wert in rsi. Rest wird in rdx gespeichert und Wert der ganzzahligen Division in rax
</code></pre>

<p>ACHTUNG: Prüfe vor der Division, ob der Wert, der sich in rdx befindet, korrekt ist. Dort könnte sich 1. ein Wert befinden, der nichts mit der gewollten Rechnung zu tun hat und 2. ein Wert drin befinden der nach der Division erhalten bleiben sollte.</p>

<h4>IMUL reg (value 1) und IDIV reg (value 1):</h4>

<p>Definition: Analog zu MUL/DIV, aber mit signed Zahlen (d.h. Zahlen mit Vorzeichen)</p>

<h3>Vergleiche/Sprünge und Bedinge Sprünge:</h3>

<h4>CMP reg (value 1), value / CMP reg (value 1), reg (value 2):</h4>

<p>Definition: Vergleiche ein Register mit einem Wert bzw. mit dem Wert eines weiteren Registers. Diese Operation setzt Bits im Flag-Register die später für Bedingte-Sprünge verwendet werden könnten</p>

<p>Beispiel:</p>

<pre><code>CMP rax, rsi ; Vergleiche rax mit dem Wert aus rsi
CMP rax, 2   ; Vergleiche rax mit dem Wert 2
</code></pre>

<h4>JMP some-lable:</h4>

<p>Definition: Setze den Programm Counter (PC) auf die Adresse des angegebenen Lable (some_lable)</p>

<p>Beispiel:</p>

<pre><code>[...]
JMP .some_lable
[...]

.some_lable:
[Do something]
</code></pre>

<h4>JL some-lable / JB some-lable / JG some-lable / JA some-lable / JE some-lable / JNE some-lable &hellip;</h4>

<p>Definition: Springe, wenn ein bestimmtes Bit im Flag-Register gesetzt ist. Vor dieser Operation sollte ein <em>CMP reg1, reg2</em> oder <em>CMP reg1, value</em> stattgefunden haben!</p>

<table><thead>
<tr>
<th>Sprung Bezeichnung</th>
<th>Bedeutung</th>
</tr>
</thead><tbody>
<tr>
<td>JE</td>
<td>&ldquo;Jump equal&rdquo; - Springe, wenn die Werte des CMP die selben sind</td>
</tr>
<tr>
<td>JNE</td>
<td>&ldquo;Jump not equal&rdquo; - Springe wenn die Werte des CMP nicht die selben sind</td>
</tr>
<tr>
<td>JL</td>
<td>&ldquo;Jump less&rdquo; - Springe wenn reg1 &lt; reg2 oder reg1 &lt; value (signed number)</td>
</tr>
<tr>
<td>JG</td>
<td>&ldquo;Jump greater&rdquo; - Springe wenn reg 1 &gt; reg 2 oder reg 1 &gt; value (signed number)</td>
</tr>
<tr>
<td>JB</td>
<td>&ldquo;Jump above&rdquo; - Springe wenn reg 1 &lt; reg 2 oder reg 1 &lt; value (unsigned number)</td>
</tr>
<tr>
<td>JA</td>
<td>&ldquo;Jump below&rdquo; - Springe wenn reg 1 &gt; reg 2 oder reg 1 &gt; value (unsigned number)</td>
</tr>
<tr>
<td>JLE / JGE / &hellip;</td>
<td>&ldquo;Jump less equal&rdquo; / &ldquo;Jump greater equal&rdquo; - Analog zu den Sprüngen oben nur mit equal</td>
</tr>
</tbody></table>

<p>Beispiele:</p>

<pre><code>[...]
CMP rax, 2
JL .some_lable
; execute here if rax &gt;= 2
[...]

.some_lable:
; execute here if rax &lt; 2
</code></pre>

<h4>TEST reg (value 1), value / TEST reg (value 1), reg (value 2):</h4>

<p>Definition: Führt ein logisches und auf das erste Register mit dem Wert des zweiten Registers bzw. dem angegebenen Wert aus. Das Ergebnis wird verworfen, doch die Flags: SF (signed flag gibt an ob es sich um eine negative Zahl handelt), ZF (zero flag gibt an ob das Ergebnis die Zahl 0 repräsentiert), PF (parity flag gibt an ob das Ergebnis gerade/ungerade ist &lt;=&gt; ob das letzte Bit gesetzt ist).</p>

<p>Anmerkungen:</p>

<ul>
<li>JE/JZ testet, ob das ZF-Bit gesetzt ist. Also wenn hier die Verundung das Ergebnis 0 ergab</li>
</ul>

<h3>Sichern von Daten:</h3>

<h4>Grundlagen Stack:</h4>

<p>Ein Stack ist eine Datenstruktur die einer Last-In-First-Out-Warteschlange entspringt. D.h. das letzte Element welches hinzugefügt wurde wird das erste Element sein, welches entnommen wird.
Diese Datenstruktur ist in Assembly Hardwaremäßig implementiert. Dafür werden zwei Werte benötigt: der Stack-Base-Pointer und der Stack-Pointer. Der Stack-Base-Pointer zeigt immer auf den Beginn des Stacks währenddessen der Stack-Pointer auf die nächste freie Adresse zeigt. WICHTIGT: nach dem Funktionsaufruf (also vor dem RET Befehl) muss der Stack-Pointer wieder auf der selben Stelle sein wie zu beginn des Funktionsaufrufs!</p>

<h4>PUSH reg:</h4>

<p>Um Daten auf den Stack zu legen nutzt man den PUSH-Befehl. Dieser legt dann den Wert des angegebenen Registers auf den Stack ab und aktualisiert den Stack-Pointer.</p>

<p>Beispiel:</p>

<pre><code>PUSH rax
PUSH esi
PUSH cl
</code></pre>

<h4>POP reg:</h4>

<p>Um Daten vom Stack wieder zu nehmen nutzt man den POP-Befehl. Dieser lädt das Datum welches zuletzt auf den Stack gelegt wurde und speichert es in das jeweilige Register.</p>

<p>Beispiel:</p>

<pre><code>POP cl
POP esi
POP rax
</code></pre>

<p>WICHTIG: Es muss in umgekehrter Reigenfolge gepopt werden wie die Elemente gepusht wurde. Dies ist der Fall wegen der LIFO-Struktur des Stacks!</p>

<h3>Aufrufen einer weiteren Funktion:</h3>

<h4>CALL some-lable:</h4>

<p>Die CALL-Funktion wird genutzt um eine Subroutine aufzurufen. Anders als beim JMP-Befehl wird nach der jeweiligen Subroutine wieder an die Stelle des CALL zurückgesprungen. D.h. das beim Aufruf eines CALL-Befehls der PC und das PSW auf den Stack gepusht werden bevor der Sprung zur jeweiligen Adresse durchgeführt wird.</p>

<p>WICHTIG: Achtet beim Aufruf der CALL-Funktion darauf, dass ihr die Calling-Convention beachtet (bsp. Eingaberegister füllen oder jeweilige Register sichern)</p>

<p>Beispiel:</p>

<pre><code>some_function:
    ...
    CALL some-other-function
    ; RET der Subroutine macht hier weiter
    ...

some_other_function:
    ...
    RET
</code></pre>

<h2>Assembly-Tricks:</h2>

<h4>Ein Register bereinigen / auf 0 setzen</h4>

<p>Um den Wert eines Registers auf 0 zu setzen könnt ihr einfach die Zahl 0 in das jeweilige Register setzen:</p>

<pre><code>MOV rax, 0 ; Setze rax = 0
</code></pre>

<p>Optional hierzu könnt ihr die XOR-Bit-Operation nutzen. Da XOR ein gegebenen Bit auf 0 setze &lt;=&gt; beide Register-Einträge sind 0 ODER beide Registereinträge sind 1 folgt daraus, dass ein XOR mit dem selben Wert das jeweilige Register auf 0 setzen wird. Dies hat also den selben Effekt wie ein MOV Befehl ist jedoch aus Implementierungsgründen effizienter.</p>

<pre><code>XOR rax, rax ; Setze rax = 0

e.g rax = 1101 1111

XOR rax, rax
=&gt;
1101 1111
1101 1111
---------
0000 0000 
</code></pre>

<h4>Ganzzahlige Multiplikation/Division um eine zweier Potenz</h4>

<p>&hellip;.</p>

<h2>How-To-Compile:</h2>

<p>Wir stellen euch zu jeder Assembly-Aufgabe einen C-Wrapper zur Verfügung. Keine Sorge, den müsst ihr noch nicht verstehen.</p>

<p>Da Assembly eine menschenlesbare Version von Maschinen-Code ist muss diese zunächst Compiled/Übersetzt werden. Dazu erstellt ihr zunächst mit Hilfe von NASM eine .o Datei aus eurem Assembly-Code:</p>

<pre><code>&gt;&gt; nasm -f elf64 -o PROGRAMM_NAME.o PROGRAMM_NAME.asm
</code></pre>

<p>Die Flag &ldquo;-f elf64&rdquo; teilt NASM mit, dass die Ausgabe für x64 Linux Übersetzt werden soll.</p>

<p>Nun müsst ihr auch den C-Wrapper compilieren und eine weitere &ldquo;.o&rdquo; Datei erzeugen:</p>

<pre><code>&gt;&gt; cc -O2 -c -o PROGRAMM_NAME_wrapper.o PROGRAMM_NAME_wrapper.c
</code></pre>

<p>Die Flag -O2 teilt unserem Compiler mit, dass wir die Optimierungsstufe 2 nutzen wollen (automatische Optimierung unseres C-Codes).</p>

<p>Anschließend müssen wir noch beide &ldquo;.o&rdquo; Datein verlinken:</p>

<pre><code>&gt;&gt; cc -o PROGRAMM_NAME PROGRAMM_NAME_wrapper.o PROGRAMM_NAME.o
</code></pre>

<p>Abschließend solltet ihr eine Datei &ldquo;PROGRAMM_NAME&rdquo; besitzen. Diese könnt ihr wie folgt ausführen:</p>

<pre><code>&gt;&gt; ./PRGRAMM_NAMME [parameter 1] [parameter 2] [parameter 3] ...+
</code></pre>

<p>Alternativ könnt ihr auch einfach die gegebene MAKEFILE nutzen</p>

<pre><code>&gt;&gt; make
</code></pre>

<h2>Quellen:</h2>

<p>https://en.wikibooks.org/wiki/X86<em>Assembly/X86</em>Architecture</p>

<p>https://en.wikipedia.org/wiki/X86<em>calling</em>conventions</p>

<p>https://stackoverflow.com/questions/18024672/what-registers-are-preserved-through-a-linux-x86-64-function-call</p>
</body></html>